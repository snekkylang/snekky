import hxargs.Args;
import haxe.io.Bytes;
import haxe.io.Path;
import vm.VirtualMachine;
import compiler.Compiler;
import parser.Parser;
import lexer.Lexer;
import build.Version as MacroVersion;
#if target.sys
import sys.io.File;
import repl.Repl;
#end

@:expose
class Snekky {

    public static final Version = MacroVersion.getVersionString();

    public static function tokenizeString(fileName:String, code:String) {
        return new Lexer(fileName, code);
    }

    public static function compileString(fileName:String, code:String, debug:Bool, compress:Bool, warnings:Bool):Bytes {
        final lexer = new Lexer(fileName, code);

        final parser = new Parser(lexer, false);
        parser.generateAst();

        final compiler = new Compiler(debug, warnings);
        compiler.compile(parser.ast);
        final byteCode = compiler.getByteCode(compress);  

        return byteCode;
    }

    public static function evaluateBytes(byteCode:Bytes) {
        final vm = new VirtualMachine(byteCode);
        vm.eval();
    }
    
    public static function main() {
        #if target.sys
        final args = Sys.args();
        final config = {
            debug: true,
            compress: true,
            inputPath: null,
            dumpPath: null,
            showHelp: false,
            warnings: true
        };
        
        final argumentHandler = Args.generate([
            @doc("Print this message")
            ["--help", "-h"] => function() {
                config.showHelp = true;
            },
            @doc("Print version info and exit")
            ["--version", "-v"] => function() {
                Console.println('Snekky $Version');
                Sys.exit(0);
            },
            @doc("Specify where to place the generated bytecode")
            ["--output", "-o"] => function(path:String) {
                config.dumpPath = path;
            },
            @doc("Compile without debug information")
            ["--no-debug"] => function() {
                config.debug = false;
            },
            @doc("Do not compress the generated bytecode")
            ["--no-compress"] => function() {
                config.compress = false;
            },
            @doc("Suppress all compiler warnings")
            ["--no-warnings"] => function() {
                config.warnings = false;
            },
            _ => function(input:String) {
                config.inputPath = input;
            }
        ]);

        argumentHandler.parse(args);

        #if interp
        config.inputPath = "input.snek";
        #end

        if (config.showHelp) {
            Console.println("Usage: snekky [-options] <input>");
            Console.println("");
            Console.println("Options:");
            Console.println(argumentHandler.getDoc());
            return;
        }

        if (args.length == 0) {
            final repl = new Repl();
            repl.start();
        } else {
            final fileName = config.inputPath;
            final compress = config.dumpPath != null && config.compress;
    
            if (Path.extension(fileName) == "snek") {
                final code = try {
                    File.getContent(fileName);
                } catch (err) {
                    Console.println('Error: Unable to open file $fileName');
                    return;
                };
    
                final byteCode = compileString(fileName, code, config.debug, compress, config.warnings);
    
                if (config.dumpPath != null) {
                    File.saveBytes('${config.dumpPath}.bite', byteCode);
                    return;
                }
    
                evaluateBytes(byteCode);
            } else {
                final byteCode = try {
                    File.getBytes('./$fileName');
                } catch (err) {
                    Console.println('Error: Unable to open file $fileName');
                    return;
                };

                evaluateBytes(byteCode);
            }
        }
        #end
    }
}
